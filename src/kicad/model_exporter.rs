use crate::error::{KicadError, Result};
use std::collections::HashMap;

pub struct ModelExporter;

impl ModelExporter {
    pub fn new() -> Self {
        Self
    }

    /// Convert OBJ format to VRML (.wrl) format
    pub fn obj_to_wrl(&self, obj_data: &[u8]) -> Result<String> {
        let obj_str = String::from_utf8_lossy(obj_data);

        // Parse OBJ file
        let vertices = self.parse_obj_vertices(&obj_str)?;
        let faces = self.parse_obj_faces(&obj_str)?;
        let _materials = self.parse_obj_materials(&obj_str);

        // Generate VRML output
        let mut output = String::new();

        // VRML header
        output.push_str("#VRML V2.0 utf8\n");
        output.push_str("#Generated by e2k\n\n");

        // Shape node
        output.push_str("Shape {\n");
        output.push_str("  appearance Appearance {\n");
        output.push_str("    material Material {\n");
        output.push_str("      diffuseColor 0.8 0.8 0.8\n");
        output.push_str("      specularColor 0.5 0.5 0.5\n");
        output.push_str("      shininess 0.5\n");
        output.push_str("    }\n");
        output.push_str("  }\n");

        // Geometry
        output.push_str("  geometry IndexedFaceSet {\n");
        output.push_str("    coord Coordinate {\n");
        output.push_str("      point [\n");

        // Write vertices
        for (i, vertex) in vertices.iter().enumerate() {
            output.push_str(&format!("        {:.6} {:.6} {:.6}", vertex.0, vertex.1, vertex.2));
            if i < vertices.len() - 1 {
                output.push_str(",\n");
            } else {
                output.push_str("\n");
            }
        }

        output.push_str("      ]\n");
        output.push_str("    }\n");

        // Write faces
        output.push_str("    coordIndex [\n");
        for (i, face) in faces.iter().enumerate() {
            output.push_str("      ");
            for (j, idx) in face.iter().enumerate() {
                output.push_str(&format!("{}", idx));
                if j < face.len() - 1 {
                    output.push_str(", ");
                }
            }
            output.push_str(", -1");
            if i < faces.len() - 1 {
                output.push_str(",\n");
            } else {
                output.push_str("\n");
            }
        }
        output.push_str("    ]\n");

        output.push_str("    solid FALSE\n");
        output.push_str("  }\n");
        output.push_str("}\n");

        Ok(output)
    }

    /// Export STEP file (just write binary data as-is)
    pub fn export_step(&self, step_data: &[u8]) -> Result<Vec<u8>> {
        Ok(step_data.to_vec())
    }

    fn parse_obj_vertices(&self, obj: &str) -> Result<Vec<(f64, f64, f64)>> {
        let mut vertices = Vec::new();

        for line in obj.lines() {
            let line = line.trim();
            if line.starts_with("v ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 4 {
                    let x = parts[1].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex X coordinate".to_string()))?;
                    let y = parts[2].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex Y coordinate".to_string()))?;
                    let z = parts[3].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex Z coordinate".to_string()))?;
                    vertices.push((x, y, z));
                }
            }
        }

        Ok(vertices)
    }

    fn parse_obj_faces(&self, obj: &str) -> Result<Vec<Vec<i32>>> {
        let mut faces = Vec::new();

        for line in obj.lines() {
            let line = line.trim();
            if line.starts_with("f ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                let mut face = Vec::new();

                for part in parts.iter().skip(1) {
                    // Face format can be: v, v/vt, v/vt/vn, or v//vn
                    let vertex_str = part.split('/').next().unwrap_or(part);
                    if let Ok(idx) = vertex_str.parse::<i32>() {
                        // OBJ indices are 1-based, convert to 0-based
                        face.push(idx - 1);
                    }
                }

                if !face.is_empty() {
                    faces.push(face);
                }
            }
        }

        Ok(faces)
    }

    fn parse_obj_materials(&self, obj: &str) -> HashMap<String, Material> {
        let mut materials = HashMap::new();

        // Simple material parsing (can be extended)
        for line in obj.lines() {
            let line = line.trim();
            if line.starts_with("usemtl ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    let name = parts[1].to_string();
                    materials.insert(name.clone(), Material {
                        name,
                        diffuse: (0.8, 0.8, 0.8),
                        specular: (0.5, 0.5, 0.5),
                        shininess: 0.5,
                    });
                }
            }
        }

        materials
    }
}

impl Default for ModelExporter {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
struct Material {
    name: String,
    diffuse: (f64, f64, f64),
    specular: (f64, f64, f64),
    shininess: f64,
}
