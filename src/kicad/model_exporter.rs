use crate::error::{KicadError, Result};
use std::collections::HashMap;

pub struct ModelExporter;

impl ModelExporter {
    pub fn new() -> Self {
        Self
    }

    /// Convert OBJ format to VRML (.wrl) format
    pub fn obj_to_wrl(&self, obj_data: &[u8]) -> Result<String> {
        let obj_str = String::from_utf8_lossy(obj_data);

        // Parse OBJ file
        let vertices = self.parse_obj_vertices(&obj_str)?;
        let faces = self.parse_obj_faces(&obj_str)?;
        let materials = self.parse_obj_materials(&obj_str);

        // Optimize vertices (remove duplicates)
        let (optimized_vertices, optimized_faces) = self.optimize_vertices(&vertices, &faces);

        // Get material properties (use first material or default)
        let material = materials.values().next().cloned().unwrap_or_else(|| Material {
            name: "default".to_string(),
            ambient: (0.2, 0.2, 0.2),
            diffuse: (0.8, 0.8, 0.8),
            specular: (0.5, 0.5, 0.5),
            shininess: 0.5,
            transparency: 1.0,
        });

        // Generate VRML output
        let mut output = String::new();

        // VRML header
        output.push_str("#VRML V2.0 utf8\n");
        output.push_str("#Generated by e2k\n\n");

        // Shape node
        output.push_str("Shape {\n");
        output.push_str("  appearance Appearance {\n");
        output.push_str("    material Material {\n");
        output.push_str(&format!("      ambientIntensity {:.2}\n",
            (material.ambient.0 + material.ambient.1 + material.ambient.2) / 3.0));
        output.push_str(&format!("      diffuseColor {:.2} {:.2} {:.2}\n",
            material.diffuse.0, material.diffuse.1, material.diffuse.2));
        output.push_str(&format!("      specularColor {:.2} {:.2} {:.2}\n",
            material.specular.0, material.specular.1, material.specular.2));
        output.push_str(&format!("      shininess {:.2}\n", material.shininess));
        output.push_str(&format!("      transparency {:.2}\n", 1.0 - material.transparency));
        output.push_str("    }\n");
        output.push_str("  }\n");

        // Geometry
        output.push_str("  geometry IndexedFaceSet {\n");
        output.push_str("    coord Coordinate {\n");
        output.push_str("      point [\n");

        // Write vertices
        for (i, vertex) in optimized_vertices.iter().enumerate() {
            output.push_str(&format!("        {:.6} {:.6} {:.6}", vertex.0, vertex.1, vertex.2));
            if i < optimized_vertices.len() - 1 {
                output.push_str(",\n");
            } else {
                output.push_str("\n");
            }
        }

        output.push_str("      ]\n");
        output.push_str("    }\n");

        // Write faces
        output.push_str("    coordIndex [\n");
        for (i, face) in optimized_faces.iter().enumerate() {
            output.push_str("      ");
            for (j, idx) in face.iter().enumerate() {
                output.push_str(&format!("{}", idx));
                if j < face.len() - 1 {
                    output.push_str(", ");
                }
            }
            output.push_str(", -1");
            if i < optimized_faces.len() - 1 {
                output.push_str(",\n");
            } else {
                output.push_str("\n");
            }
        }
        output.push_str("    ]\n");

        output.push_str("    solid FALSE\n");
        output.push_str("  }\n");
        output.push_str("}\n");

        Ok(output)
    }

    /// Export STEP file (just write binary data as-is)
    pub fn export_step(&self, step_data: &[u8]) -> Result<Vec<u8>> {
        Ok(step_data.to_vec())
    }

    fn parse_obj_vertices(&self, obj: &str) -> Result<Vec<(f64, f64, f64)>> {
        let mut vertices = Vec::new();

        for line in obj.lines() {
            let line = line.trim();
            if line.starts_with("v ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 4 {
                    let x = parts[1].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex X coordinate".to_string()))?;
                    let y = parts[2].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex Y coordinate".to_string()))?;
                    let z = parts[3].parse::<f64>()
                        .map_err(|_| KicadError::ModelExport("Invalid vertex Z coordinate".to_string()))?;
                    // Convert from mm to inches by dividing by 2.54
                    vertices.push((x / 2.54, y / 2.54, z / 2.54));
                }
            }
        }

        Ok(vertices)
    }

    fn parse_obj_faces(&self, obj: &str) -> Result<Vec<Vec<i32>>> {
        let mut faces = Vec::new();

        for line in obj.lines() {
            let line = line.trim();
            if line.starts_with("f ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                let mut face = Vec::new();

                for part in parts.iter().skip(1) {
                    // Face format can be: v, v/vt, v/vt/vn, or v//vn
                    let vertex_str = part.split('/').next().unwrap_or(part);
                    if let Ok(idx) = vertex_str.parse::<i32>() {
                        // OBJ indices are 1-based, convert to 0-based
                        face.push(idx - 1);
                    }
                }

                if !face.is_empty() {
                    faces.push(face);
                }
            }
        }

        Ok(faces)
    }

    fn parse_obj_materials(&self, obj: &str) -> HashMap<String, Material> {
        let mut materials = HashMap::new();
        let mut current_material: Option<Material> = None;

        for line in obj.lines() {
            let line = line.trim();

            if line.starts_with("newmtl ") {
                // Save previous material if exists
                if let Some(mat) = current_material.take() {
                    materials.insert(mat.name.clone(), mat);
                }

                // Start new material
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    current_material = Some(Material {
                        name: parts[1].to_string(),
                        ambient: (0.2, 0.2, 0.2),
                        diffuse: (0.8, 0.8, 0.8),
                        specular: (0.5, 0.5, 0.5),
                        shininess: 0.5,
                        transparency: 1.0,
                    });
                }
            } else if let Some(ref mut mat) = current_material {
                if line.starts_with("Ka ") {
                    // Ambient color
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 4 {
                        if let (Ok(r), Ok(g), Ok(b)) = (
                            parts[1].parse::<f64>(),
                            parts[2].parse::<f64>(),
                            parts[3].parse::<f64>()
                        ) {
                            mat.ambient = (r, g, b);
                        }
                    }
                } else if line.starts_with("Kd ") {
                    // Diffuse color
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 4 {
                        if let (Ok(r), Ok(g), Ok(b)) = (
                            parts[1].parse::<f64>(),
                            parts[2].parse::<f64>(),
                            parts[3].parse::<f64>()
                        ) {
                            mat.diffuse = (r, g, b);
                        }
                    }
                } else if line.starts_with("Ks ") {
                    // Specular color
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 4 {
                        if let (Ok(r), Ok(g), Ok(b)) = (
                            parts[1].parse::<f64>(),
                            parts[2].parse::<f64>(),
                            parts[3].parse::<f64>()
                        ) {
                            mat.specular = (r, g, b);
                        }
                    }
                } else if line.starts_with("d ") {
                    // Transparency (dissolve)
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        if let Ok(d) = parts[1].parse::<f64>() {
                            mat.transparency = d;
                        }
                    }
                } else if line.starts_with("Ns ") {
                    // Shininess (specular exponent)
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        if let Ok(ns) = parts[1].parse::<f64>() {
                            // Convert from OBJ range (0-1000) to VRML range (0-1)
                            mat.shininess = (ns / 1000.0).min(1.0);
                        }
                    }
                }
            }
        }

        // Save last material
        if let Some(mat) = current_material {
            materials.insert(mat.name.clone(), mat);
        }

        materials
    }

    fn optimize_vertices(&self, vertices: &[(f64, f64, f64)], faces: &[Vec<i32>])
        -> (Vec<(f64, f64, f64)>, Vec<Vec<i32>>) {
        let mut link_dict: HashMap<i32, usize> = HashMap::new();
        let mut new_vertices = Vec::new();
        let mut new_faces = Vec::new();

        for face in faces {
            let mut new_face = Vec::new();
            for &idx in face {
                let new_idx = *link_dict.entry(idx).or_insert_with(|| {
                    let idx_usize = idx as usize;
                    if idx_usize < vertices.len() {
                        let new_idx = new_vertices.len();
                        new_vertices.push(vertices[idx_usize]);
                        new_idx
                    } else {
                        0
                    }
                });
                new_face.push(new_idx as i32);
            }
            new_faces.push(new_face);
        }

        (new_vertices, new_faces)
    }
}

impl Default for ModelExporter {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
struct Material {
    name: String,
    ambient: (f64, f64, f64),
    diffuse: (f64, f64, f64),
    specular: (f64, f64, f64),
    shininess: f64,
    transparency: f64,
}
