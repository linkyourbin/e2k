use clap::Parser;
use std::path::PathBuf;
use crate::error::{AppError, Result};

#[derive(Parser, Debug)]
#[command(name = "e2k")]
#[command(version = "0.3.0")]
#[command(about = "Fast EasyEDA/LCSC to KiCad converter with parallel downloads", long_about = None)]
pub struct Cli {
    /// LCSC component ID (e.g., C2040)
    #[arg(long, value_name = "ID", conflicts_with = "batch")]
    pub lcsc_id: Option<String>,

    /// Batch mode: read LCSC IDs from a file (one ID per line)
    #[arg(long, value_name = "FILE", conflicts_with = "lcsc_id")]
    pub batch: Option<PathBuf>,

    /// Convert symbol only
    #[arg(long)]
    pub symbol: bool,

    /// Convert footprint only
    #[arg(long)]
    pub footprint: bool,

    /// Convert 3D model only
    #[arg(long = "3d")]
    pub model_3d: bool,

    /// Convert all (symbol + footprint + 3D model)
    #[arg(long)]
    pub full: bool,

    /// Output directory path
    #[arg(short, long, default_value = ".")]
    pub output: PathBuf,

    /// Overwrite existing components
    #[arg(long)]
    pub overwrite: bool,

    /// Use KiCad v5 legacy format
    #[arg(long)]
    pub v5: bool,

    /// Use global paths (KICAD6_3DMODEL_DIR) instead of project-relative paths (KIPRJMOD) for 3D models
    #[arg(long)]
    pub project_relative: bool,

    /// Enable debug logging
    #[arg(long)]
    pub debug: bool,

    /// Continue on error in batch mode (skip failed components)
    #[arg(long)]
    pub continue_on_error: bool,

    /// Number of parallel downloads in batch mode (default: 4)
    #[arg(long, default_value = "4")]
    pub parallel: usize,
}

impl Cli {
    pub fn validate(&self) -> Result<()> {
        // Check if at least one ID source is provided
        if self.lcsc_id.is_none() && self.batch.is_none() {
            return Err(AppError::Other(
                "Either --lcsc-id or --batch must be specified".to_string()
            ));
        }

        // Validate LCSC ID format if provided
        if let Some(ref id) = self.lcsc_id {
            if !id.starts_with('C') || id.len() < 2 {
                return Err(AppError::Easyeda(
                    crate::error::EasyedaError::InvalidLcscId(id.clone())
                ));
            }
        }

        // Check if at least one conversion option is selected
        if !self.symbol && !self.footprint && !self.model_3d && !self.full {
            return Err(AppError::Other(
                "At least one conversion option must be specified (--symbol, --footprint, --3d, or --full)".to_string()
            ));
        }

        Ok(())
    }

    /// Get list of LCSC IDs to process (either single ID or from batch file)
    pub fn get_lcsc_ids(&self) -> Result<Vec<String>> {
        if let Some(ref id) = self.lcsc_id {
            // Single ID mode
            Ok(vec![id.clone()])
        } else if let Some(ref batch_file) = self.batch {
            // Batch mode: read from file
            use std::fs;
            use std::io::{BufRead, BufReader};

            let file = fs::File::open(batch_file)
                .map_err(|e| AppError::Other(format!("Failed to open batch file: {}", e)))?;

            let reader = BufReader::new(file);
            let mut ids = Vec::new();

            for (line_num, line) in reader.lines().enumerate() {
                let line = line.map_err(|e| AppError::Other(format!("Failed to read line {}: {}", line_num + 1, e)))?;
                let trimmed = line.trim();

                // Skip empty lines and comments
                if trimmed.is_empty() || trimmed.starts_with('#') {
                    continue;
                }

                // Validate LCSC ID format
                if !trimmed.starts_with('C') || trimmed.len() < 2 {
                    log::warn!("Line {}: Invalid LCSC ID format '{}', skipping", line_num + 1, trimmed);
                    continue;
                }

                ids.push(trimmed.to_string());
            }

            if ids.is_empty() {
                return Err(AppError::Other("No valid LCSC IDs found in batch file".to_string()));
            }

            log::info!("Loaded {} LCSC IDs from batch file", ids.len());
            Ok(ids)
        } else {
            Err(AppError::Other("No LCSC ID source specified".to_string()))
        }
    }

    pub fn kicad_version(&self) -> KicadVersion {
        if self.v5 {
            KicadVersion::V5
        } else {
            KicadVersion::V6
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KicadVersion {
    V5,
    V6,
}
